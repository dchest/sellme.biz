---
author: "dchest"
date: 2009-04-29 00:04:03 +00:00
status: "Publish"
title: "Плавное пролистывание списков"
---
<p>Маленькие детали для user experience важны не меньше больших. Вообще, из маленьких деталей как раз и строится впечатление от интерфейса. Одна из таких деталей &#8212; плавное пролистывание списков с помощью клавиатуры.</p>
<p><em>Моментально реагировать на действия пользователя должно то, чем он непосредственно манипулирует в текущий момент. То есть, если пользователь управляет списком (листает его), то изменение выделения должно происходить моментально, в то время как остальные связанные действия (отображение результата изменения выделения) можно отложить на некоторое небольшое время. Если интерфейс делает так, то он, не являясь на самом деле быстрее, будет восприниматься как более быстрый. Вспомните (к виндузятникам обращаюсь), как это неприятно, когда курсор мышки застревает.</em></p>
<p>Ситуация кажется простой &#8212; по нажатию клавиш &#8220;вниз&#8221; и &#8220;вверх&#8221; выделение в списке меняется и загружается какой-то контент, связанный с пунктом. Например, список писем в почтовом ящике. Нажимаем &#8220;вниз&#8221;, получаем следующее письмо. Проблема в том, что при неправильной реализации (или по недосмотру), если загрузка контента занимает много времени, мы лишаем пользователя возможности быстро и плавно листать список: в случае, если контент загружается в том же треде, в котором происходит выделение в списке, загрузка контента блокирует выделение следующего пункта.</p>
<p>Если в Finder включить Quick Look и пролистать некэшированную папку со множеством &#8220;тяжелых&#8221; (для Quick Look) файлов, листание будет тормозить, пока превьюшки не будут кэшированы.</p>
<p>То же самое в iTunes, если включить показ обложки для выбранной песни.</p>

<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/iy0JAk5xky0?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>

<p><em>Сравните скорость листания с выключенным показом обложки и с включенным. На скринкасте это менее заметно, чем на самом деле &#8212; при листании во втором случае такое чувство, что к клавишам добавили жесткости нажатия.</em></p>
<p>В Mail листание происходит по нажатию клавиши, а загрузка контента &#8211; по ее отпусканию. Если вы нажимаете клавишу со стрелкой, то пока ее держите, список листается. Отпускаете клавишу &#8212; выбранное письмо показывается. Таким образом, прокрутка всегда происходит быстро и плавно.</p>

<iframe width="640" height="360" src="https://www.youtube-nocookie.com/embed/QYquZuxE6Ac?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen></iframe>

<p>Это один из способов решения проблемы, и пожалуй, самый лучший, если его немного доработать: если выделение останавливается в начале списка или в конце, загрузка контента должна происходить сразу, а не по отпусканию клавиши. Иначе, пока вы держите кнопку, выделение будет стоять на одном пункте, а загружен будет другой.</p>
<p>Я попробовал реализовать такой способ, но так как я использую NSTableView с bindings, назначение выделенного пункта и отдача этого значения контроллеру происходит где-то глубоко внутри таблицы, поэтому задача оказалась непростой.</p>
<p>Но есть другой способ.</p>
<h2>Реализация</h2>
<p>Что если загружать контент не сразу, а через какое-то малюсенькое время после того, как выделение было сделано? Для этого добавляем в Run Loop таймер<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>, который будет вызывать метод загрузки. Если в то время, когда таймер сработает, выделение изменится, метод просто загрузит именно нынешний выделенный пункт.</p>
<pre><code>
  NSTimeInterval interval = 0.1;
  loadTimer = [NSTimer scheduledTimerWithTimeInterval:interval 
				target:self 
				selector:@selector(updateContent:) 
				userInfo:nil 				
				repeats:NO];
</code></pre>
<p><em>(Я так не форматирую код &#8212; это чтобы в блоге поместилось без горизонтального листания. Обычно я пишу все в одну строчку, а переносами занимается Xcode со включенным параметром &#8220;Wrap lines in editor&#8221;.)</em></p>
<p>Теперь листается чуть лучше, но все равно тормозит, потому что контент загружается через несколько пунктов. Тогда мы просто отсрочим обновление контента еще на чуть-чуть при вызове метода, в котором мы создаем таймер:</p>
<pre><code>
  NSTimeInterval interval = 0.1;
  if (!loadTimer)
	  loadTimer = [NSTimer scheduledTimerWithTimeInterval:interval
					target:self
					selector:@selector(updateContent:)
					userInfo:nil
					repeats:NO];
  else
	  [loadTimer setFireDate:
                  [NSDate dateWithTimeIntervalSinceNow:interval]];
</code></pre>
<p>Не забыв обнулить <code>loadTimer</code> в <code>updateContent:</code></p>
<pre><code>
  - (void)updateContent:(NSTimer *)timer;
  {
	  // ... загрузить контент ...
	  loadTimer = nil;
  }
</code></pre>
<p>Теперь список листается плавно. Единственная проблема, хотя на глаз это и не очень заметно, при листании по нажатию и отпусканию клавиши, загрузка происходит не мгновенно, а через interval. Чтобы это обойти, можно у текущего события выяснить, не является ли оно повторным нажатием клавиши, и если да, то оставить interval со значением 0.1, а если нет, то сделать его нулевым (в таком случае, загрузка произойдет в следующей итерации Run Loop):</p>
<pre><code>
  NSTimeInterval interval = 0.0;
  NSEvent *currentEvent = [[NSApplication sharedApplication] currentEvent];
  if ([currentEvent type] == NSKeyDown &amp;&amp; [currentEvent isARepeat])
  	  interval = 0.1;
	
  if (!loadTimer)
	  loadTimer = [NSTimer scheduledTimerWithTimeInterval:interval
					target:self
					selector:@selector(updateContent:)
					userInfo:nil
					repeats:NO];
  else
	  [loadTimer setFireDate:
                  [NSDate dateWithTimeIntervalSinceNow:interval]];
</code></pre>
<p>Назначение 0.0 интервалу, то есть, выполнение действия в следующей итерации Run Loop, на мой взгляд, даже лучше, чем если бы мы загружали контент моментально &#8212; таким образом новое выделение в таблице успевает отобразиться до того, как будет загружен контент (см. начало заметки).</p>
<p>Надо заметить, что интервал в 0.1, подобранный мной экпериментальным путем &#8212; это не универсальный ответ<sup class="footnote" id="fnr2"><a href="#fn2">2</a></sup>, а компромисс между меньшим ожиданием загрузки контента при повторе клавиши и установленной скорости повтора клавиш. По умолчанию скорость повтора в Mac OS X стоит такая:</p>
<p><img src="/pics/tableview-browsing/key-repeat-rate.png" alt="" /></p>
<p><em>(У меня стоит максимальная, люблю быстро листать)</em></p>
<p>Значение в 0.1 работает для дефолтной скорости повтора и выше. Все что ниже и так медленно листает списки, поэтому, наверное, тут плавность не так важна.</p>
<p>P.S. Используйте <em>accessor methods</em> или <em>properties</em> для loadTimer чтобы избежать багов.</p>
<p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> Напомню, что NSTimer &#8212; легкая штука. Для него не создается отдельный тред,  таймер просто добавляется в Run Loop.</p>
<p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> Универсальный ответ <del>- 42 :</del>)</p>
