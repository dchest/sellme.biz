---
author: "dchest"
date: 2012-11-16 23:40:56 +00:00
markup: markdown
status: "Publish"
title: "Немножко нового кода"
---
Написал на Go [BLAKE-512](https://github.com/dchest/blake512) (в дополнение к [BLAKE-256](https://github.com/dchest/blake256)) и [Skein](https://github.com/dchest/skein) ([Threefish](https://github.com/dchest/threefish) тоже). Обе хэш-функции не выиграли [SHA-3](http://en.wikipedia.org/wiki/SHA-3), выиграл [Keccak](http://keccak.noekeon.org/). Плохо, Keccak в софте медленный.

[SipHash](https://www.131002.net/siphash/)! Я рассказывал про SipHash? Это криптографическая функция (MAC): даете ей 128-битный ключ и текст любой длины, она считает 64-битный хэш. Очень быстро работает (&gt; 1 гигабайта в секунду на компе 2009 года), но самое главное, быстро считает хэш очень коротких текстов (8 байт, например). Ее придумали [Jean-Philippe Aumasson](https://www.131002.net/) и [Dan Bernstein](http://cr.yp.to) для того, чтобы победить [HashDoS](https://www.google.com/search?q=hashdos). Ruby на нее [недавно перешел](http://www.ruby-lang.org/en/news/2012/11/09/ruby19-hashdos-cve-2012-5371/) и [Rust](http://www.rust-lang.org/) тоже. Если будете писать хэш-таблицу, обязательно используйте SipHash -- она почти так же быстра, как MurMurHash или CityHash, но в отличие от них, безопасна (повторяю -- *криптографическая* функция). Люди-то думали, что достаточно впихнуть любое рэндомное число куда-нибудь в функцию, и тогда коллизии невозможно угадать; а Жан-Филиппе с Бернштейном показали, что это не так: коллизии, например, для MurMur можно сделать такие, что они вообще не будут зависеть от seed будь он хоть трижды рэндомным. Так вот, я, конечно же, написал [пакет для Go](https://github.com/dchest/siphash).

А еще я перевел на Go [Бернштейновскую криптобиблиотеку NaCl](http://nacl.cr.yp.to/), а потом оказалось, что [Adam Langley](http://www.imperialviolet.org/) работал над тем же. Мы объединили мои версии на Go, его ассемблерные версии, он написал новый интерфейс (лучше), и теперь все это дело живет в [официальном репозитории go.crypto](http://code.google.com/p/go.crypto/nacl) ([документация тут](http://go.pkgdoc.org/code.google.com/p/go.crypto/nacl)). Если вам надо что-то зашифровать в своей программе, обязательно используйте NaCl. Она в несколько раз быстрее какой бы то ни было нехардварной комбинации MAC с AES, а самое главное, интерфейс -- проще некуда.

В [go.crypto](http://code.google.com/p/go.crypto/), кстати, теперь еще живет [scrypt](http://go.pkgdoc.org/code.google.com/p/go.crypto/scrypt), которую я написал в апреле. [Scrypt](https://www.tarsnap.com/scrypt.html) придумал [Colin Percival](http://www.daemonology.net/blog/). Если вам нужен хэш пароля, или надо пароль преобразовать в ключ для шифрования, используете scrypt и будете счастливы. А не как LinkedIn, у которого утекли пароли, или Bitrix24, который [*хвастается* тем, что хэширует пароли "двойным MD5"](http://www.bitrix24.com/security/). Интересно, как они пришли к тому, что двойной MD5 лучше, чем, например, пятерной? Хе-хе.

[Richard Hipp](http://www.hwaci.com/drh/) придумал для [прототипа SQLite4](http://www.sqlite.org/src4/doc/trunk/www/index.wiki) хорошую [кодировку для беззнаковых целых чисел](http://www.sqlite.org/src4/doc/trunk/www/varint.wiki). Опять же, я написал [пакетик для Go](https://github.com/dchest/varuint). Смысл кодировки в том, что маленькие числа кодируются в маленькое количество байт, а большие числа -- в большее количество байт, но не равномерно, как, например, у [гугловского varint](http://golang.org/pkg/encoding/binary/#PutUvarint) используемого в [компрессоре Snappy](code.google.com/p/snappy/), а оптимизированно под маленькие числа. Если Snappy кодирует число 200 в два байта, то эта кодировка -- в один. Кроме того, по первому байту можно определить сколько еще байт в числе, а у Snappy для этого нужно читать байты до финального.

WebP. Помните еще такой формат картинок? Google придумал, Opera использует в "Turbo". Так вот они теперь поддерживают альфа-канал в lossy картинках и добавили lossless, который сжимает лучше PNG. Я обновил свой [QuickLook плагин](http://www.codingrobots.org/p/webp-quicklook/) (это который показывает картинки, если нажать пробел в Finder) -- теперь он поддерживает все нововведения.

Еще я написал кучу строк кода для всяких секретных проектов, но пока рассказать о них не могу, потому что секретные проекты часто не релизятся.

Вроде все.

PS. За моим кодом можно следить на [GitHub](https://github.com/dchest).

